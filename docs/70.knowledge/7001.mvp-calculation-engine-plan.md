# MVP計算エンジン実装計画書

| ドキュメントバージョン | 作成日     | 更新日     | 更新者         |
| :--------------------- | :--------- | :--------- | :------------- |
| 1.0.0                  | 2025/10/05 | 2025/10/05 | Claude (Sonnet 4.5) |

## 1. 目的

本ドキュメントは、Xenharmonic Voyager MVPの核となる**協和度計算エンジン**の実装計画を定義する。Sethares (1993) の音響ラフネスモデルに基づき、N-EDO音律における和音の協和度を定量的に計算する高品質なPython実装を構築する。

## 2. 実装スコープ

### 2.1 対象MVP要件

| 要件ID     | 概要                         | 実装方法                                   |
| :--------- | :--------------------------- | :----------------------------------------- |
| MVP-101    | 音律選択 (12-EDO, 19-EDO)    | `TuningSystem(edo=N)` クラス               |
| MVP-102    | 和音構成音選択 (3和音)       | `ChordInput` Pydantic検証                  |
| MVP-201    | 協和度計算                   | `ConsonanceCalculator` + Setharesモデル    |
| MVP-202    | 固定音色モデル (ノコギリ波)  | `SawtoothTimbre` (1/k減衰, 10倍音)         |
| MVP-301    | 協和度スコア表示             | `calculate_consonance()` → float           |
| SH-301     | 比較ゲージ表示 (Should)      | 12-EDO長三和音基準値との比較               |

### 2.2 実装対象外 (将来拡張)

- CO-101: 任意N-EDO入力 (アーキテクチャは対応済み、UIのみ制限)
- CO-102: 音色モデル選択 (Protocol設計済み、実装は1種のみ)
- WO-401: 音声再生機能

## 3. アーキテクチャ設計

### 3.1 レイヤー構造

```
┌──────────────────────────────────────────┐
│  Presentation Layer (UI)                 │
│  - app.py (Streamlit)                    │
├──────────────────────────────────────────┤
│  Application Layer (Public API)          │
│  - calculator.py                         │
│  - __init__.py                           │
├──────────────────────────────────────────┤
│  Service Layer (Orchestration)           │
│  - services/consonance_service.py        │
├──────────────────────────────────────────┤
│  Domain Layer (Business Logic)           │
│  - domain/tuning.py                      │
│  - domain/harmonics.py                   │
├──────────────────────────────────────────┤
│  Acoustics Layer (Physical Models)       │
│  - acoustics/roughness.py                │
├──────────────────────────────────────────┤
│  Infrastructure Layer                    │
│  - constants.py                          │
└──────────────────────────────────────────┘
```

**レイヤー間の依存関係:**
- 上位レイヤーは下位レイヤーに依存可能
- 下位レイヤーは上位レイヤーに依存禁止
- 同一レイヤー内の依存は最小化

### 3.2 ファイル構成

#### 新規作成ファイル (18ファイル)

**実装モジュール (9ファイル):**
```
src/
├── constants.py                           # 物理定数・モデルパラメータ
├── domain/
│   ├── __init__.py
│   ├── tuning.py                          # TuningSystem (N-EDO周波数計算)
│   └── harmonics.py                       # Harmonic, HarmonicSeries, TimbreModel
├── acoustics/
│   ├── __init__.py
│   └── roughness.py                       # クリティカルバンド幅、ラフネス計算
└── services/
    ├── __init__.py
    └── consonance_service.py              # ConsonanceCalculator
```

**テストモジュール (9ファイル):**
```
tests/
├── domain/
│   ├── __init__.py
│   ├── test_tuning.py
│   └── test_harmonics.py
├── acoustics/
│   ├── __init__.py
│   └── test_roughness.py
└── services/
    ├── __init__.py
    └── test_consonance_service.py
```

#### 更新ファイル (4ファイル)

- `src/calculator.py` - ConsonanceServiceへの接続
- `src/__init__.py` - 公開API export
- `tests/test_calculator.py` - 統合テスト拡張
- `app.py` - Streamlit UI実装

## 4. 数学的基盤: Setharesモデル

### 4.1 N-EDO周波数計算

```
f(n) = f_base × 2^(n/N)
```

**パラメータ:**
- `f_base`: 基準周波数 (デフォルト: 440 Hz = A4)
- `N`: EDO値 (12, 19, など)
- `n`: ステップインデックス (0 ≤ n < N)

**実装例 (12-EDO, A4基準):**
- Step 0: 440.0 Hz (A4)
- Step 7: 659.3 Hz (E5, 完全5度)
- Step 12: 880.0 Hz (A5, オクターブ)

### 4.2 ノコギリ波倍音モデル

```
amplitude_k = 1/k     (k = 1, 2, 3, ..., 10)
frequency_k = k × f_fundamental
```

**特性:**
- 第1倍音 (基音): 振幅 1.0
- 第2倍音: 振幅 0.5
- 第10倍音: 振幅 0.1
- 豊かな倍音スペクトラムを持つ音色

### 4.3 クリティカルバンド幅 (簡易Plomp-Levelt)

```
CB(f) ≈ 0.24 × f + 25 Hz
```

**根拠:**
- Plomp & Levelt (1965) の実験データに基づく簡易近似
- Bark scaleの完全な計算より高速
- 可聴域 (20-20000 Hz) で十分な精度

### 4.4 ラフネス関数 (Sethares 1993)

**不協和度曲線:**
```
g(Δf, s) = exp(-b1 × s × Δf) - exp(-b2 × s × Δf)
```

**パラメータ:**
- `Δf`: 2つの倍音間の周波数差 (Hz)
- `s`: クリティカルバンド幅 = CB(f_min)
- `b1 = 3.5`: 曲線形状パラメータ1
- `b2 = 5.75`: 曲線形状パラメータ2

**2倍音間のラフネス:**
```
R(f1, f2, a1, a2) = a1 × a2 × g(|f2 - f1|, CB(min(f1, f2)))
```

**特性:**
- ユニゾン (Δf = 0): R = 0 (協和)
- クリティカルバンド付近: R が最大 (最大不協和)
- 広い音程: R → 0 (協和)

### 4.5 和音の総ラフネス

```
Total_Roughness = Σ(all harmonic pairs) R(fi, fj, ai, aj)
```

**計算手順:**
1. 各音の倍音列を生成 (10倍音 × N音)
2. 全倍音ペアの組み合わせを計算
3. 各ペアのラフネスを計算
4. 総和を取る

**例 (3和音):**
- 総倍音数: 3 × 10 = 30
- ペア数: C(30, 2) = 435
- **低いラフネス = 高い協和度**

### 4.6 参考文献

- Sethares, W. A. (1993). "Local consonance and the relationship between timbre and scale." *Journal of the Acoustical Society of America*, 94(3), 1218-1228.
- Plomp, R., & Levelt, W. J. M. (1965). "Tonal consonance and critical bandwidth." *Journal of the Acoustical Society of America*, 38, 548-560.

## 5. 主要クラス設計

### 5.1 Domain Layer

#### TuningSystem (domain/tuning.py)

```python
@dataclass(frozen=True)
class TuningSystem:
    """N-EDO音律システム"""
    edo: int                    # EDO値 (例: 12, 19)
    base_frequency: float = 440.0  # 基準周波数 (Hz)

    def get_frequency(self, step: int) -> float:
        """ステップインデックスから周波数を計算"""

    def get_interval_cents(self, steps: int) -> float:
        """ステップから音程をセント値で取得"""
```

#### TimbreModel (domain/harmonics.py)

```python
class TimbreModel(Protocol):
    """音色モデルのインターフェース"""

    def generate_harmonics(self, fundamental: float, num_harmonics: int) -> HarmonicSeries:
        """基音から倍音列を生成"""
        ...

@dataclass(frozen=True)
class Harmonic:
    """単一倍音"""
    frequency: float  # Hz
    amplitude: float  # 0.0-1.0

@dataclass(frozen=True)
class HarmonicSeries:
    """倍音列"""
    harmonics: tuple[Harmonic, ...]

class SawtoothTimbre:
    """ノコギリ波音色 (1/k減衰)"""

    def generate_harmonics(self, fundamental: float, num_harmonics: int = 10) -> HarmonicSeries:
        """ノコギリ波の倍音列を生成"""
```

### 5.2 Acoustics Layer

#### roughness.py (acoustics/roughness.py)

```python
def critical_bandwidth(frequency: float) -> float:
    """クリティカルバンド幅を計算

    CB(f) ≈ 0.24 * f + 25 Hz
    """

def calculate_dissonance_curve(
    freq_diff: float,
    critical_band: float,
    b1: float = 3.5,
    b2: float = 5.75
) -> float:
    """Sethares不協和度曲線を計算"""

def calculate_roughness_pair(harm1: Harmonic, harm2: Harmonic) -> float:
    """2つの倍音間のラフネスを計算"""
```

### 5.3 Service Layer

#### ConsonanceCalculator (services/consonance_service.py)

```python
class ConsonanceCalculator:
    """協和度計算サービス"""

    def __init__(
        self,
        timbre_model: TimbreModel | None = None,
        num_harmonics: int = 10
    ):
        self.timbre_model = timbre_model or SawtoothTimbre()
        self.num_harmonics = num_harmonics

    def calculate_for_chord(
        self,
        tuning: TuningSystem,
        note_indices: list[int]
    ) -> float:
        """和音の協和度スコアを計算

        Returns:
            総ラフネス値 (低いほど協和的)
        """
```

### 5.4 Application Layer

#### calculator.py (公開API)

```python
def calculate_consonance(edo: int, notes: list[int]) -> float:
    """協和度スコアを計算 (公開API)

    Args:
        edo: EDO値 (例: 12, 19)
        notes: 和音構成音のインデックス (例: [0, 4, 7])

    Returns:
        協和度スコア (ラフネス値、低いほど協和的)
    """
```

## 6. テスト戦略

### 6.1 テストピラミッド

```
        /\
       /  \      E2E Tests (app.py手動テスト)
      /────\
     / Integ \   Integration Tests (test_consonance_service.py)
    /────────\
   /   Unit   \  Unit Tests (各モジュール)
  /────────────\
```

### 6.2 単体テスト (Unit Tests)

#### test_tuning.py
- ✓ 12-EDO既知周波数の検証 (A4=440, A5=880)
- ✓ 19-EDO周波数計算
- ✓ エッジケース: step=0, step=N
- ✓ 入力検証: 負のstep, N境界外

#### test_harmonics.py
- ✓ ノコギリ波振幅減衰 (1, 0.5, 0.333...)
- ✓ 倍音周波数の倍数関係 (f, 2f, 3f, ...)
- ✓ 10倍音生成の検証
- ✓ 異なる基音での動作

#### test_roughness.py
- ✓ クリティカルバンド幅の計算精度
- ✓ 不協和度曲線の形状 (0→最大→0)
- ✓ 対称性: R(f1, f2) = R(f2, f1)
- ✓ ユニゾンでのラフネス = 0
- ✓ 振幅の影響検証

### 6.3 統合テスト (Integration Tests)

#### test_consonance_service.py
- ✓ 12-EDO長三和音 [0, 4, 7] vs 短三和音 [0, 3, 7]
- ✓ 完全8度 (オクターブ) の低ラフネス検証
- ✓ 短2度・三全音の高ラフネス検証
- ✓ 19-EDOでの特徴的和音検証

#### test_calculator.py (API層)
- ✓ 入力検証エラー処理
- ✓ エンドツーエンド計算フロー
- ✓ 既知の音楽的和音での妥当性検証

### 6.4 検証観点

**数学的正しさ:**
- 既知の協和音程で低ラフネス
- 既知の不協和音程で高ラフネス

**物理的妥当性:**
- ユニゾン → ラフネス = 0
- 対称性: R(A, B) = R(B, A)
- 非負性: ラフネス ≥ 0

**エッジケース:**
- 単音 (trivial: roughness = 0)
- 重複音符
- 極端な周波数領域

### 6.5 カバレッジ目標

- 計算ロジック (domain/acoustics/services): **100%**
- 統合フロー: **95%以上**
- 全体: **90%以上**

## 7. 実装順序 (Bottom-up)

### Phase 1: Core Domain Models (依存なし)

1. `src/constants.py` 作成
   - 物理定数定義
   - モデルパラメータ定義

2. `src/domain/tuning.py` 実装
   - TuningSystemクラス
   - 周波数計算メソッド

3. `tests/domain/test_tuning.py` 作成・実行
   - ✓ 12-EDO既知値検証
   - ✓ pytest実行してグリーン確認

### Phase 2: Harmonics (tuningに依存)

4. `src/domain/harmonics.py` 実装
   - Harmonic, HarmonicSeries dataclasses
   - TimbreModel Protocol
   - SawtoothTimbre実装

5. `tests/domain/test_harmonics.py` 作成・実行
   - ✓ ノコギリ波スペクトラム検証
   - ✓ pytest実行

### Phase 3: Acoustics (純粋な数学、domain依存なし)

6. `src/acoustics/roughness.py` 実装
   - critical_bandwidth()
   - calculate_dissonance_curve()
   - calculate_roughness_pair()

7. `tests/acoustics/test_roughness.py` 作成・実行
   - ✓ 数学的正しさ検証
   - ✓ Setharesカーブ形状確認
   - ✓ pytest実行

### Phase 4: Service Integration (全レイヤー統合)

8. `src/services/consonance_service.py` 実装
   - ConsonanceCalculatorクラス
   - 全倍音ペアのラフネス計算
   - 総ラフネス集計

9. `tests/services/test_consonance_service.py` 作成・実行
   - ✓ エンドツーエンド和音計算
   - ✓ 音楽的妥当性検証
   - ✓ pytest実行

### Phase 5: API Layer (Serviceのファサード)

10. `src/calculator.py` 更新
    - ConsonanceCalculatorへの配線
    - 既存ChordInput検証維持

11. `src/__init__.py` 更新
    - 必要な公開APIのexport

12. `tests/test_calculator.py` 拡張・実行
    - ✓ 公開API統合テスト
    - ✓ 全テストスイート実行

### Phase 6: UI Implementation

13. `app.py` 実装
    - Streamlit UI構築
    - EDO選択UI
    - 和音入力UI
    - スコア表示・比較ゲージ

14. 手動テスト・動作確認
    - ✓ `uv run streamlit run app.py`
    - ✓ ブラウザで動作確認

## 8. 設計原則・品質基準

### 8.1 SOLID原則

- **Single Responsibility**: 各クラスは1つの責務のみ
- **Open/Closed**: TimbreModel Protocolで拡張に開放
- **Liskov Substitution**: 抽象化の適切な設計
- **Interface Segregation**: 小さく焦点を絞ったインターフェース
- **Dependency Inversion**: 具象クラスでなく抽象に依存

### 8.2 コード品質

- **型ヒント**: 全関数・メソッドに完全な型アノテーション
- **Docstrings**: NumPy/Google スタイル、数式を含む
- **命名規則**: 明確で説明的な名前 (略語回避)
- **Pure Functions**: 副作用なし、決定的
- **Immutability**: dataclassesは`frozen=True`

### 8.3 NumPy活用

- **ベクトル化**: ループ回避、配列演算活用
- **Broadcasting**: 効率的なペアワイズ計算
- **数値安定性**: float64使用、オーバーフロー/アンダーフロー対策

### 8.4 ドキュメンテーション

```python
def critical_bandwidth(frequency: float) -> float:
    """クリティカルバンド幅を計算 (簡易Plomp-Levelt)

    CB(f) ≈ 0.24 * f + 25 Hz

    可聴域で十分な精度を持つ簡易近似式。Bark scaleの
    完全な計算より計算効率が高い。

    Args:
        frequency: 周波数 (Hz)。正の値である必要がある。

    Returns:
        クリティカルバンド幅 (Hz)

    Raises:
        ValueError: frequency <= 0の場合

    References:
        Plomp & Levelt (1965), Sethares (1993)
    """
```

## 9. 拡張性

### 9.1 将来拡張への対応

**CO-101: 任意N-EDO入力**
- TuningSystemは既に任意のN対応
- UIのドロップダウンを数値入力に変更のみ

**CO-102: 音色モデル選択**
- TimbreModel Protocolで抽象化済み
- 新しい音色クラス追加のみ:
  - `SquareWaveTimbre`
  - `TriangleWaveTimbre`
  - `CustomSpectrumTimbre`

**その他:**
- 倍音数の可変化 (現在10固定)
- 基準周波数の変更 (現在440 Hz固定)
- 複数和音のバッチ分析
- ラフネス曲線の可視化

### 9.2 Open/Closed原則の体現

- 新機能追加時に既存コード変更不要
- Protocolによる柔軟な拡張
- 依存性注入パターンの活用

## 10. 成果物チェックリスト

### 10.1 実装ファイル

- [ ] `src/constants.py`
- [ ] `src/domain/__init__.py`
- [ ] `src/domain/tuning.py`
- [ ] `src/domain/harmonics.py`
- [ ] `src/acoustics/__init__.py`
- [ ] `src/acoustics/roughness.py`
- [ ] `src/services/__init__.py`
- [ ] `src/services/consonance_service.py`
- [ ] `src/calculator.py` (更新)
- [ ] `src/__init__.py` (更新)
- [ ] `app.py` (更新)

### 10.2 テストファイル

- [ ] `tests/domain/__init__.py`
- [ ] `tests/domain/test_tuning.py`
- [ ] `tests/domain/test_harmonics.py`
- [ ] `tests/acoustics/__init__.py`
- [ ] `tests/acoustics/test_roughness.py`
- [ ] `tests/services/__init__.py`
- [ ] `tests/services/test_consonance_service.py`
- [ ] `tests/test_calculator.py` (更新)

### 10.3 品質確認

- [ ] 全テストパス (`uv run pytest`)
- [ ] カバレッジ90%以上 (`uv run pytest --cov`)
- [ ] Ruff Lintパス (`uv run ruff check .`)
- [ ] Ruff Formatパス (`uv run ruff format --check .`)
- [ ] Pre-commitフックパス (`uv run pre-commit run --all-files`)
- [ ] Streamlit起動確認 (`uv run streamlit run app.py`)
- [ ] 既知の和音で音楽的妥当性確認

## 11. 次回セッション引継ぎ情報

### 11.1 進捗確認方法

1. このドキュメントの「10. 成果物チェックリスト」を確認
2. TodoList状態を確認
3. `uv run pytest`でテスト実行状況確認

### 11.2 中断時の再開方法

1. 最後に完了したPhaseを特定
2. 次のPhaseの最初のタスクから再開
3. 各Phase完了時は必ずテスト実行

### 11.3 重要な設計判断

- **基準周波数**: A4 = 440 Hz (国際標準)
- **倍音数**: 10 (要件明記、計算負荷とのバランス)
- **ラフネスパラメータ**: b1=3.5, b2=5.75 (Sethares論文値)
- **クリティカルバンド**: 簡易式 (0.24f + 25) 採用

---

**実装完了の定義:**
全チェックリスト項目が完了し、Streamlit UIで12-EDO長三和音と19-EDO和音の協和度スコアが表示され、比較ゲージが機能すること。
