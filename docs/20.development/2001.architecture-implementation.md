# ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨å®Ÿè£…è©³ç´°

**æœ€çµ‚æ›´æ–°**: 2025-10-18

---

## ç›®æ¬¡

1. [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦](#1-ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦)
2. [Domain Layerå®Ÿè£…](#2-domain-layerå®Ÿè£…)
3. [Acoustics Layerå®Ÿè£…](#3-acoustics-layerå®Ÿè£…)
4. [Service Layerå®Ÿè£…](#4-service-layerå®Ÿè£…)
5. [API Layerå®Ÿè£…](#5-api-layerå®Ÿè£…)
6. [Presenter Layerå®Ÿè£…](#6-presenter-layerå®Ÿè£…)
7. [UI Layerå®Ÿè£…](#7-ui-layerå®Ÿè£…)
8. [ãƒ†ã‚¹ãƒˆæˆ¦ç•¥](#8-ãƒ†ã‚¹ãƒˆæˆ¦ç•¥)ï¼ˆè©³ç´°ã¯[`3001.testing.md`](../30.quality/3001.testing.md)å‚ç…§ï¼‰
9. [ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒå¯Ÿ](#9-ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒå¯Ÿ)

---

## 1. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### 1.1 ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹æˆ

Xenharmonic Voyagerã®è¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³ã¯ã€**ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**ã®åŸå‰‡ã«åŸºã¥ãã€ä»¥ä¸‹ã®6å±¤ã§æ§‹æˆã•ã‚Œã‚‹ï¼š

```mermaid
graph TB
    UI[UI Layer<br/>ui/<br/>Streamlit View Components]
    Presenter[Presenter Layer<br/>src/visualization<br/>ViewModel Preparation]
    API[API Layer<br/>calculator.py<br/>Pydantic Validation]
    Service[Service Layer<br/>consonance_service.py<br/>Orchestration]
    Domain[Domain Layer<br/>tuning.py / harmonics.py<br/>Business Logic]
    Acoustics[Acoustics Layer<br/>roughness.py<br/>Acoustic Models]

    UI --> Presenter
    Presenter --> API
    Presenter --> Service
    API --> Service
    Service --> Domain
    Service --> Acoustics
    Acoustics --> Domain

    style UI fill:#e1f5ff
    style Presenter fill:#f0e1ff
    style API fill:#fff4e1
    style Service fill:#ffe1f5
    style Domain fill:#e1ffe1
    style Acoustics fill:#ffe1e1
```

### 1.2 ä¾å­˜é–¢ä¿‚ã®åŸå‰‡

**ä¾å­˜æ€§é€†è»¢ã®åŸå‰‡ï¼ˆDependency Inversion Principleï¼‰:**

- ä¸Šä½å±¤ã¯ä¸‹ä½å±¤ã«ä¾å­˜
- ä¸‹ä½å±¤ã¯ä¸Šä½å±¤ã‚’çŸ¥ã‚‰ãªã„
- ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆProtocolï¼‰ã‚’é€šã˜ãŸæŠ½è±¡åŒ–

**å…·ä½“ä¾‹:**

```python
# âœ… è‰¯ã„ä¾‹ï¼šService â†’ Protocol â†’ Domain
class ConsonanceCalculator:
    def __init__(self, timbre_model: TimbreModel):  # Protocol
        self._timbre_model = timbre_model

# âŒ æ‚ªã„ä¾‹ï¼šDomain â†’ Service
class TuningSystem:
    def __init__(self, calculator: ConsonanceCalculator):  # ä¸Šä½å±¤ã¸ã®ä¾å­˜
        ...
```

### 1.3 å„å±¤ã®è²¬å‹™

| å±¤ | è²¬å‹™ | å…·ä½“çš„ãªã‚¯ãƒ©ã‚¹/ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« |
|----|------|-------------------------|
| **UI Layer** | Streamlitã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«ã‚ˆã‚‹æç”»ã®ã¿ | `ui/` å†…ã®å„Viewãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« |
| **Presenter Layer** | UIè¡¨ç¤ºç”¨ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ã€ViewModelç”Ÿæˆã€ã‚°ãƒ©ãƒ•ç”Ÿæˆ | `src/visualization/` å†…ã®Presenterã¨ViewModel |
| **API Layer** | å…¥åŠ›æ¤œè¨¼ã€å‹å¤‰æ›ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° | `calculator.py`, `ChordInput` |
| **Service Layer** | ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ | `ConsonanceCalculator`, `ConsonanceResult` |
| **Domain Layer** | ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã®ã‚«ãƒ—ã‚»ãƒ«åŒ– | `TuningSystem`, `Harmonic`, `SawtoothTimbre` |
| **Acoustics Layer** | éŸ³éŸ¿ç‰©ç†ãƒ¢ãƒ‡ãƒ«ã®å®Ÿè£… | `roughness.py` ã®å„é–¢æ•° |

### 1.4 è¨­è¨ˆåŸå‰‡ã®é©ç”¨

#### SOLIDåŸå‰‡

1. **Single Responsibility**: å„ã‚¯ãƒ©ã‚¹ã¯å˜ä¸€ã®è²¬å‹™ï¼ˆä¾‹ï¼š`TuningSystem`ã¯å‘¨æ³¢æ•°è¨ˆç®—ã®ã¿ï¼‰
2. **Open/Closed**: `TimbreModel` Protocolã«ã‚ˆã‚‹æ‹¡å¼µæ€§
3. **Liskov Substitution**: `TimbreModel`ã®å®Ÿè£…ã¯äº¤æ›å¯èƒ½
4. **Interface Segregation**: æœ€å°é™ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
5. **Dependency Inversion**: æŠ½è±¡ï¼ˆProtocolï¼‰ã¸ã®ä¾å­˜

#### ä¸å¤‰æ€§ï¼ˆImmutabilityï¼‰

ã™ã¹ã¦ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ä¸å¤‰ï¼ˆ`frozen=True` dataclassï¼‰ï¼š

- **ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•**: ä¸¦è¡Œå‡¦ç†ã§ã®å®‰å…¨æ€§
- **äºˆæ¸¬å¯èƒ½æ€§**: å‰¯ä½œç”¨ã®ãªã„é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°
- **ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£**: çŠ¶æ…‹å¤‰åŒ–ã‚’è€ƒæ…®ä¸è¦

---

## 2. Domain Layerå®Ÿè£…

Domain Layerã¯ã€éŸ³æ¥½ç†è«–ã¨N-EDOç†è«–ã®ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã‚’ç´”ç²‹ãªPythonã‚³ãƒ¼ãƒ‰ã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã€‚

### 2.1 TuningSystemï¼ˆéŸ³å¾‹ã‚·ã‚¹ãƒ†ãƒ ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/domain/tuning.py`

#### 2.1.1 ã‚¯ãƒ©ã‚¹å®šç¾©

```python
@dataclass(frozen=True)
class TuningSystem:
    """N-EDOéŸ³å¾‹ã‚·ã‚¹ãƒ†ãƒ ã€‚

    ä¸å¤‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ã€åŸºæº–å‘¨æ³¢æ•°ã¨EDOå€¤ã‹ã‚‰å‘¨æ³¢æ•°è¨ˆç®—ã‚’æä¾›ã€‚
    """
    edo: int
    base_frequency: float = DEFAULT_BASE_FREQUENCY  # 440.0 Hz

    def __post_init__(self) -> None:
        """æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã€‚"""
        if self.edo <= 0:
            raise ValueError(f"EDO must be positive, got {self.edo}")
        if self.base_frequency <= 0:
            raise ValueError(f"Base frequency must be positive, got {self.base_frequency}")
```

**è¨­è¨ˆä¸Šã®æ±ºå®š:**

- `frozen=True`: ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã€‚ä¸€åº¦ç”Ÿæˆã•ã‚ŒãŸã‚‰å¤‰æ›´ä¸å¯ã€‚
- `__post_init__`: dataclassã®åˆæœŸåŒ–å¾Œã«å®Ÿè¡Œã•ã‚Œã‚‹æ¤œè¨¼ãƒ¡ã‚½ãƒƒãƒ‰ã€‚
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°: ä¸€èˆ¬çš„ãªä½¿ç”¨ä¾‹ï¼ˆA4 = 440 Hzï¼‰ã‚’ç°¡æ½”ã«è¨˜è¿°å¯èƒ½ã€‚

#### 2.1.2 å‘¨æ³¢æ•°è¨ˆç®—ãƒ¡ã‚½ãƒƒãƒ‰

```python
def get_frequency(self, step: int) -> float:
    """N-EDOã‚¹ãƒ†ãƒƒãƒ—ã‹ã‚‰å‘¨æ³¢æ•°ã‚’è¨ˆç®—ã€‚

    Formula: f(n) = f_base Ã— 2^(n/N)

    Args:
        step: EDOã‚¹ãƒ†ãƒƒãƒ—ï¼ˆè² æ•°ãƒ»Nä»¥ä¸Šã‚‚è¨±å¯ï¼‰

    Returns:
        å‘¨æ³¢æ•° (Hz)
    """
    return self.base_frequency * (2.0 ** (step / self.edo))
```

**å®Ÿè£…ä¸Šã®æ³¨æ„ç‚¹:**

1. **æ•´æ•°é™¤ç®—ã®å›é¿**: `step / self.edo` ã¯å¸¸ã«æµ®å‹•å°æ•°ç‚¹é™¤ç®—
2. **ã¹ãä¹—æ¼”ç®—**: `**` æ¼”ç®—å­ã‚’ä½¿ç”¨ã€‚`pow()` ã‚„ `math.pow()` ã‚ˆã‚Šç°¡æ½”
3. **å‹ãƒ’ãƒ³ãƒˆ**: æ˜ç¤ºçš„ãª `float` è¿”ã‚Šå€¤ã§ã€å‹å®‰å…¨æ€§ã‚’ç¢ºä¿

**æ•°å€¤ä¾‹:**

```python
tuning = TuningSystem(edo=12, base_frequency=440.0)
tuning.get_frequency(0)   # â†’ 440.0 Hz (A4)
tuning.get_frequency(7)   # â†’ 659.25 Hz (E5, å®Œå…¨5åº¦)
tuning.get_frequency(12)  # â†’ 880.0 Hz (A5, ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–)
tuning.get_frequency(-12) # â†’ 220.0 Hz (A3, ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸‹)
```

#### 2.1.3 ã‚»ãƒ³ãƒˆè¨ˆç®—ãƒ¡ã‚½ãƒƒãƒ‰

```python
def get_interval_cents(self, steps: int) -> float:
    """N-EDOéŸ³ç¨‹ã‚’ã‚»ãƒ³ãƒˆã«å¤‰æ›ã€‚

    Formula: cents = (1200 / N) Ã— steps

    Args:
        steps: EDOã‚¹ãƒ†ãƒƒãƒ—æ•°

    Returns:
        éŸ³ç¨‹ (cents)
    """
    return (1200.0 / self.edo) * steps
```

**ç”¨é€”:**

éŸ³ç¨‹ã®ç›´æ„Ÿçš„ãªæ¯”è¼ƒã€‚ä¾‹ãˆã°ã€12-EDOã®7ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆå®Œå…¨5åº¦ï¼‰ã¯700ã‚»ãƒ³ãƒˆã€ç´”æ­£5åº¦ï¼ˆ3:2ï¼‰ã¯ç´„702ã‚»ãƒ³ãƒˆãªã®ã§ã€ç´„2ã‚»ãƒ³ãƒˆã®èª¤å·®ãŒã‚ã‚‹ã€‚

#### 2.1.4 å’ŒéŸ³å‘¨æ³¢æ•°è¨ˆç®—ï¼ˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰

```python
def get_frequencies_for_chord(self, steps: list[int]) -> np.ndarray:
    """å’ŒéŸ³ã®å„éŸ³ã®å‘¨æ³¢æ•°ã‚’ä¸€æ‹¬è¨ˆç®—ã€‚

    Args:
        steps: EDOã‚¹ãƒ†ãƒƒãƒ—ã®ãƒªã‚¹ãƒˆ

    Returns:
        å‘¨æ³¢æ•°é…åˆ— (NumPy array)
    """
    return np.array([self.get_frequency(step) for step in steps], dtype=np.float64)
```

**NumPyä½¿ç”¨ã®åˆ©ç‚¹:**

- **å‹ã®çµ±ä¸€**: ã™ã¹ã¦ `float64`
- **ãƒ™ã‚¯ãƒˆãƒ«æ¼”ç®—**: ä¸‹æµã§ã®åŠ¹ç‡çš„ãªè¨ˆç®—
- **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**: Pythonãƒªã‚¹ãƒˆã‚ˆã‚ŠåŠ¹ç‡çš„

### 2.2 Harmonicï¼ˆå€éŸ³ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/domain/harmonics.py`

#### 2.2.1 Harmonicãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹

```python
@dataclass(frozen=True)
class Harmonic:
    """å˜ä¸€ã®å€éŸ³æˆåˆ†ã€‚

    Attributes:
        frequency: å‘¨æ³¢æ•° (Hz)
        amplitude: æŒ¯å¹… [0.0, 1.0]
    """
    frequency: float
    amplitude: float

    def __post_init__(self) -> None:
        if self.frequency <= 0:
            raise ValueError(f"Frequency must be positive, got {self.frequency}")
        if not (0.0 <= self.amplitude <= 1.0):
            raise ValueError(f"Amplitude must be in [0, 1], got {self.amplitude}")
```

**ä¸å¤‰æ€§ã®æ„ç¾©:**

å€éŸ³ã¯ç‰©ç†çš„ã«ä¸€åº¦ç”Ÿæˆã•ã‚ŒãŸã‚‰å¤‰æ›´ã•ã‚Œãªã„æ¦‚å¿µã€‚ä¸å¤‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¡¨ç¾ã™ã‚‹ã“ã¨ã§ã€æ•°å­¦çš„ãªç´”ç²‹æ€§ã‚’ä¿ã¤ã€‚

#### 2.2.2 HarmonicSeriesãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹

```python
@dataclass(frozen=True)
class HarmonicSeries:
    """å€éŸ³åˆ—ï¼ˆè¤‡æ•°ã®å€éŸ³ã®é›†åˆï¼‰ã€‚

    Attributes:
        harmonics: å€éŸ³ã®ã‚¿ãƒ—ãƒ«ï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼‰
    """
    harmonics: tuple[Harmonic, ...]

    def __post_init__(self) -> None:
        if not self.harmonics:
            raise ValueError("Harmonic series must contain at least one harmonic")

    def __len__(self) -> int:
        return len(self.harmonics)

    def get_frequencies(self) -> np.ndarray:
        """å‘¨æ³¢æ•°é…åˆ—ã‚’æŠ½å‡ºã€‚"""
        return np.array([h.frequency for h in self.harmonics], dtype=np.float64)

    def get_amplitudes(self) -> np.ndarray:
        """æŒ¯å¹…é…åˆ—ã‚’æŠ½å‡ºã€‚"""
        return np.array([h.amplitude for h in self.harmonics], dtype=np.float64)
```

**è¨­è¨ˆã®ãƒã‚¤ãƒ³ãƒˆ:**

- `tuple` ä½¿ç”¨: ãƒªã‚¹ãƒˆã‚ˆã‚Šã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«
- `__len__`: Pythonã®çµ„ã¿è¾¼ã¿ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«æº–æ‹ 
- NumPyå¤‰æ›ãƒ¡ã‚½ãƒƒãƒ‰: ä¸‹æµã§ã®é«˜é€Ÿè¨ˆç®—ã®ãŸã‚

### 2.3 TimbreModel Protocol

#### 2.3.1 Protocolå®šç¾©

```python
from typing import Protocol

class TimbreModel(Protocol):
    """éŸ³è‰²ãƒ¢ãƒ‡ãƒ«ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€‚

    ç•°ãªã‚‹å€éŸ³æ§‹é€ ã‚’æŒã¤éŸ³è‰²ï¼ˆçŸ©å½¢æ³¢ã€ä¸‰è§’æ³¢ã€æ¥½å™¨å›ºæœ‰ãªã©ï¼‰ã‚’
    çµ±ä¸€çš„ã«æ‰±ã†ãŸã‚ã®æŠ½è±¡åŒ–ã€‚
    """

    def generate_harmonics(
        self,
        fundamental: float,
        num_harmonics: int = 10
    ) -> HarmonicSeries:
        """åŸºéŸ³ã‹ã‚‰å€éŸ³åˆ—ã‚’ç”Ÿæˆã€‚

        Args:
            fundamental: åŸºéŸ³å‘¨æ³¢æ•° (Hz)
            num_harmonics: ç”Ÿæˆã™ã‚‹å€éŸ³æ•°

        Returns:
            HarmonicSeries
        """
        ...
```

**Protocolã®åˆ©ç‚¹:**

- **ãƒ€ãƒƒã‚¯ã‚¿ã‚¤ãƒ”ãƒ³ã‚°**: æ˜ç¤ºçš„ãªç¶™æ‰¿ä¸è¦
- **æ‹¡å¼µæ€§**: æ–°ã—ã„éŸ³è‰²ãƒ¢ãƒ‡ãƒ«ã‚’å®¹æ˜“ã«è¿½åŠ å¯èƒ½
- **å‹ãƒã‚§ãƒƒã‚¯**: mypyã§ã®é™çš„å‹ãƒã‚§ãƒƒã‚¯ãŒå¯èƒ½

#### 2.3.2 SawtoothTimbreå®Ÿè£…

```python
class SawtoothTimbre:
    """ãƒã‚³ã‚®ãƒªæ³¢éŸ³è‰²ãƒ¢ãƒ‡ãƒ«ã€‚

    å€éŸ³æŒ¯å¹…ãŒ 1/k ã§æ¸›è¡°ã™ã‚‹å¤å…¸çš„ãªéŸ³è‰²ã€‚
    """

    def generate_harmonics(
        self,
        fundamental: float,
        num_harmonics: int = 10
    ) -> HarmonicSeries:
        # å…¥åŠ›æ¤œè¨¼
        if fundamental <= 0:
            raise ValueError(f"Fundamental frequency must be positive, got {fundamental}")
        if num_harmonics < 1:
            raise ValueError(f"Number of harmonics must be >= 1, got {num_harmonics}")

        # NumPyãƒ™ã‚¯ãƒˆãƒ«åŒ–è¨ˆç®—
        harmonic_numbers = np.arange(1, num_harmonics + 1, dtype=np.float64)
        frequencies = fundamental * harmonic_numbers
        amplitudes = 1.0 / harmonic_numbers  # 1/kæ¸›è¡°

        # Harmonic ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆ
        harmonics = tuple(
            Harmonic(frequency=freq, amplitude=amp)
            for freq, amp in zip(frequencies, amplitudes)
        )

        return HarmonicSeries(harmonics=harmonics)
```

**å®Ÿè£…ã®è©³ç´°:**

1. **NumPyãƒ™ã‚¯ãƒˆãƒ«åŒ–**: ãƒ«ãƒ¼ãƒ—ã‚’é¿ã‘ã€é«˜é€ŸåŒ–
2. **`np.arange`**: å€éŸ³æ¬¡æ•° [1, 2, ..., num_harmonics] ã‚’ç”Ÿæˆ
3. **è¦ç´ ã”ã¨æ¼”ç®—**: `fundamental * harmonic_numbers` ã§ãƒ™ã‚¯ãƒˆãƒ«ä¹—ç®—
4. **ã‚¿ãƒ—ãƒ«å†…åŒ…è¡¨è¨˜**: ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆ

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹:**

10å€éŸ³ç”Ÿæˆã§ç´„ **10-20 Î¼s**ï¼ˆãƒã‚¤ã‚¯ãƒ­ç§’ï¼‰ã€‚ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã«ã¯ãªã‚‰ãªã„ã€‚

---

## 3. Acoustics Layerå®Ÿè£…

Acoustics Layerã¯ã€Setharesãƒ¢ãƒ‡ãƒ«ã®æ•°å­¦çš„å®šå¼åŒ–ã‚’å¿ å®Ÿã«å®Ÿè£…ã™ã‚‹ã€‚

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/acoustics/roughness.py`

### 3.1 critical_bandwidthé–¢æ•°

```python
def critical_bandwidth(frequency: float) -> float:
    """ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒãƒ³ãƒ‰å¹…ã‚’è¨ˆç®—ï¼ˆç°¡æ˜“Plomp-Leveltå¼ï¼‰ã€‚

    Formula: CB(f) â‰ˆ 0.24 Ã— f + 25 Hz

    Args:
        frequency: å‘¨æ³¢æ•° (Hz), must be > 0

    Returns:
        ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒãƒ³ãƒ‰å¹… (Hz)

    Raises:
        ValueError: frequency <= 0
    """
    if frequency <= 0:
        msg = f"Frequency must be positive, got {frequency}"
        raise ValueError(msg)

    return CB_COEFFICIENT * frequency + CB_CONSTANT
```

**å®šæ•°ã®å®šç¾©** (`src/constants.py`):

```python
CB_COEFFICIENT: float = 0.24
CB_CONSTANT: float = 25.0
```

**ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°:**

- å…¥åŠ›æ¤œè¨¼ã‚’æœ€ä¸Šéƒ¨ã§å®Ÿæ–½
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å®Ÿéš›ã®å€¤ã‚’å«ã‚ã€ãƒ‡ãƒãƒƒã‚°ã‚’å®¹æ˜“åŒ–
- `msg` å¤‰æ•°ã‚’ä½¿ç”¨ã—ã€f-string ã‚’ `raise` ã¨åˆ†é›¢ï¼ˆã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„ï¼‰

### 3.2 calculate_dissonance_curveé–¢æ•°

#### 3.2.1 åˆæœŸå®Ÿè£…ï¼ˆãƒã‚°å«ã‚€ï¼‰

```python
# âŒ èª¤ã£ãŸå®Ÿè£…ï¼ˆä¿®æ­£å‰ï¼‰
def calculate_dissonance_curve(
    frequency_difference: float,
    critical_band: float,
    b1: float = 3.5,
    b2: float = 5.75,
) -> float:
    s = critical_band  # ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒãƒ³ãƒ‰å¹…ã‚’ãã®ã¾ã¾ä½¿ç”¨
    term1 = np.exp(-b1 * s * frequency_difference)  # æŒ‡æ•°ãŒå·¨å¤§
    term2 = np.exp(-b2 * s * frequency_difference)
    return term1 - term2
```

**å•é¡Œç‚¹:**

- `s = 130.6 Hz`, `frequency_difference = 20 Hz` ã®ã¨ãã€
- `b1 * s * Î”f = 3.5 Ã— 130.6 Ã— 20 = 9142`
- `exp(-9142) â‰ˆ 0` ï¼ˆã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ï¼‰
- ã™ã¹ã¦ã®ãƒ‡ã‚£ã‚½ãƒŠãƒ³ã‚¹å€¤ãŒ0ã«ãªã‚‹

#### 3.2.2 ä¿®æ­£å¾Œã®å®Ÿè£…

```python
# âœ… æ­£ã—ã„å®Ÿè£…ï¼ˆä¿®æ­£å¾Œï¼‰
def calculate_dissonance_curve(
    frequency_difference: float,
    critical_band: float,
    b1: float = ROUGHNESS_B1,  # 3.5
    b2: float = ROUGHNESS_B2,  # 5.75
) -> float:
    """Setharesãƒ‡ã‚£ã‚½ãƒŠãƒ³ã‚¹æ›²ç·šã‚’è¨ˆç®—ã€‚

    Formula: g(x) = exp(-b1 Ã— x) - exp(-b2 Ã— x)
    where x = frequency_difference / critical_band
    """
    # å…¥åŠ›æ¤œè¨¼
    if frequency_difference < 0:
        msg = f"Frequency difference must be non-negative, got {frequency_difference}"
        raise ValueError(msg)
    if critical_band <= 0:
        msg = f"Critical band must be positive, got {critical_band}"
        raise ValueError(msg)

    # æ­£è¦åŒ–ï¼ˆé‡è¦ï¼ï¼‰
    x = frequency_difference / critical_band

    # Setharesãƒ‡ã‚£ã‚½ãƒŠãƒ³ã‚¹æ›²ç·š
    term1 = np.exp(-b1 * x)
    term2 = np.exp(-b2 * x)

    return term1 - term2
```

**ä¿®æ­£ã®ãƒã‚¤ãƒ³ãƒˆ:**

1. **æ­£è¦åŒ–**: $x = \Delta f / CB$ ã§ç„¡æ¬¡å…ƒåŒ–
2. **é©åˆ‡ãªæŒ‡æ•°ç¯„å›²**: $x \in [0, æ•°]$ ãªã®ã§ã€æŒ‡æ•°ã¯åˆç†çš„ãªç¯„å›²
3. **ã‚³ãƒ¡ãƒ³ãƒˆ**: æ­£è¦åŒ–ã®é‡è¦æ€§ã‚’æ˜è¨˜

**ãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹æ¤œè¨¼:**

```python
def test_unison_produces_zero_dissonance():
    cb = critical_bandwidth(440.0)
    dissonance = calculate_dissonance_curve(0.0, cb)
    assert dissonance == pytest.approx(0.0, abs=1e-10)  # âœ… PASS

def test_peak_near_quarter_cb():
    cb = critical_bandwidth(440.0)
    d_quarter = calculate_dissonance_curve(0.25 * cb, cb)
    d_eighth = calculate_dissonance_curve(0.125 * cb, cb)
    d_half = calculate_dissonance_curve(0.5 * cb, cb)

    assert d_quarter > d_eighth  # âœ… PASS
    assert d_quarter > d_half    # âœ… PASS
```

### 3.3 calculate_roughness_pairé–¢æ•°

```python
def calculate_roughness_pair(
    harmonic1: Harmonic,
    harmonic2: Harmonic,
    b1: float = ROUGHNESS_B1,
    b2: float = ROUGHNESS_B2,
) -> float:
    """2ã¤ã®å€éŸ³é–“ã®ãƒ©ãƒ•ãƒã‚¹ã‚’è¨ˆç®—ã€‚

    Formula: R = a1 Ã— a2 Ã— g(|f2 - f1| / CB(min(f1, f2)))

    Args:
        harmonic1: ç¬¬1å€éŸ³
        harmonic2: ç¬¬2å€éŸ³
        b1, b2: ãƒ‡ã‚£ã‚½ãƒŠãƒ³ã‚¹æ›²ç·šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

    Returns:
        ãƒ©ãƒ•ãƒã‚¹å€¤ (â‰¥ 0)
    """
    # å‘¨æ³¢æ•°å·®
    freq_diff = abs(harmonic2.frequency - harmonic1.frequency)

    # ä½ã„æ–¹ã®å‘¨æ³¢æ•°ã®CBã‚’ä½¿ç”¨ï¼ˆSethares 1993ã«æº–æ‹ ï¼‰
    min_freq = min(harmonic1.frequency, harmonic2.frequency)
    cb = critical_bandwidth(min_freq)

    # ãƒ‡ã‚£ã‚½ãƒŠãƒ³ã‚¹æ›²ç·šå€¤
    dissonance = calculate_dissonance_curve(freq_diff, cb, b1=b1, b2=b2)

    # æŒ¯å¹…ç©ã§é‡ã¿ä»˜ã‘
    amplitude_product = harmonic1.amplitude * harmonic2.amplitude

    return amplitude_product * dissonance
```

**è¨­è¨ˆä¸Šã®æ±ºå®š:**

1. **`min()` ä½¿ç”¨**: ä½ã„æ–¹ã®å‘¨æ³¢æ•°ã®CBã‚’ä½¿ç”¨ï¼ˆSetharesè«–æ–‡ã«æº–æ‹ ï¼‰
2. **`abs()` ä½¿ç”¨**: å‘¨æ³¢æ•°å·®ã¯å¸¸ã«éè² 
3. **æ®µéšçš„è¨ˆç®—**: å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’å¤‰æ•°ã«åˆ†å‰²ã—ã€å¯èª­æ€§å‘ä¸Š

**å¯¾ç§°æ€§ã®ä¿è¨¼:**

```python
assert calculate_roughness_pair(h1, h2) == calculate_roughness_pair(h2, h1)
```

`abs()` ã¨ `min()` ã®ä½¿ç”¨ã«ã‚ˆã‚Šã€å¼•æ•°ã®é †åºã«ä¾å­˜ã—ãªã„ã€‚

### 3.4 calculate_total_roughnessé–¢æ•°

```python
def calculate_total_roughness(
    harmonic_pairs: list[tuple[Harmonic, Harmonic]],
) -> float:
    """è¤‡æ•°ã®å€éŸ³ãƒšã‚¢ã®ç·ãƒ©ãƒ•ãƒã‚¹ã‚’è¨ˆç®—ã€‚

    Args:
        harmonic_pairs: (harmonic1, harmonic2) ã®ã‚¿ãƒ—ãƒ«ã®ãƒªã‚¹ãƒˆ

    Returns:
        ç·ãƒ©ãƒ•ãƒã‚¹ï¼ˆå„ãƒšã‚¢ã®å’Œï¼‰
    """
    if not harmonic_pairs:
        return 0.0

    total = 0.0
    for h1, h2 in harmonic_pairs:
        total += calculate_roughness_pair(h1, h2)

    return total
```

**å®Ÿè£…ã®ç°¡æ½”æ€§:**

- ç©ºãƒªã‚¹ãƒˆã®ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã‚’æ˜ç¤ºçš„ã«å‡¦ç†
- ã‚·ãƒ³ãƒ—ãƒ«ãªç´¯ç©ãƒ«ãƒ¼ãƒ—
- NumPy `sum()` ã¯ä½¿ã‚ãªã„ï¼ˆãƒšã‚¢ã®ãƒªã‚¹ãƒˆã‚’ãƒ™ã‚¯ãƒˆãƒ«åŒ–ã—ã«ãã„ï¼‰

---

## 4. Service Layerå®Ÿè£…

Service Layerã¯ã€Domainå±¤ã¨Acousticså±¤ã‚’çµ„ã¿åˆã‚ã›ã€å”å’Œåº¦è¨ˆç®—ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å…¨ä½“ã‚’ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã™ã‚‹ã€‚

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/services/consonance_service.py`

### 4.1 ConsonanceResultãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹

```python
@dataclass(frozen=True)
class ConsonanceResult:
    """å”å’Œåº¦è¨ˆç®—ã®çµæœã€‚

    Attributes:
        total_roughness: ç·ãƒ©ãƒ•ãƒã‚¹ï¼ˆä½ã„ = å”å’Œçš„ï¼‰
        num_notes: å’ŒéŸ³å†…ã®éŸ³æ•°
        num_harmonic_pairs: æ¯”è¼ƒã—ãŸå€éŸ³ãƒšã‚¢æ•°
        tuning_system: ä½¿ç”¨ã—ãŸéŸ³å¾‹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå‚ç…§ç”¨ï¼‰
    """
    total_roughness: float
    num_notes: int
    num_harmonic_pairs: int
    tuning_system: TuningSystem
```

**è¨­è¨ˆæ„å›³:**

- **ä¸å¤‰æ€§**: è¨ˆç®—çµæœã¯å¤‰æ›´ã•ã‚Œã‚‹ã¹ãã§ãªã„
- **ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿**: çµæœã®è§£é‡ˆã«å¿…è¦ãªæƒ…å ±ã‚’å«ã‚€
- **å‚ç…§é€éæ€§**: åŒã˜å…¥åŠ›ã‹ã‚‰å¸¸ã«åŒã˜çµæœ

### 4.2 ConsonanceCalculatorã‚¯ãƒ©ã‚¹

#### 4.2.1 åˆæœŸåŒ–

```python
class ConsonanceCalculator:
    """å”å’Œåº¦è¨ˆç®—ã‚µãƒ¼ãƒ“ã‚¹ã€‚

    TuningSystem, TimbreModel, Acousticsãƒ¢ãƒ‡ãƒ«ã‚’çµ±åˆã—ã€
    å’ŒéŸ³ã®å”å’Œåº¦ã‚’è¨ˆç®—ã™ã‚‹ã€‚
    """

    def __init__(
        self,
        tuning_system: TuningSystem,
        timbre_model: TimbreModel,  # Protocol
        num_harmonics: int = DEFAULT_NUM_HARMONICS,  # 10
    ):
        if num_harmonics < 1:
            msg = f"num_harmonics must be >= 1, got {num_harmonics}"
            raise ValueError(msg)

        self._tuning_system = tuning_system
        self._timbre_model = timbre_model
        self._num_harmonics = num_harmonics
```

**ä¾å­˜æ€§æ³¨å…¥ãƒ‘ã‚¿ãƒ¼ãƒ³:**

- `TuningSystem`: éŸ³å¾‹ã‚·ã‚¹ãƒ†ãƒ ã‚’å¤–éƒ¨ã‹ã‚‰æ³¨å…¥
- `TimbreModel`: éŸ³è‰²ãƒ¢ãƒ‡ãƒ«ã‚’å¤–éƒ¨ã‹ã‚‰æ³¨å…¥
- çµåˆåº¦ã‚’ä¸‹ã’ã€ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š

#### 4.2.2 å”å’Œåº¦è¨ˆç®—ãƒ¡ã‚½ãƒƒãƒ‰

```python
def calculate_consonance(self, chord_steps: list[int]) -> ConsonanceResult:
    """å’ŒéŸ³ã®å”å’Œåº¦ã‚’è¨ˆç®—ã€‚

    Args:
        chord_steps: N-EDOã‚¹ãƒ†ãƒƒãƒ—ã®ãƒªã‚¹ãƒˆ (ä¾‹: [0, 4, 7])

    Returns:
        ConsonanceResult

    Raises:
        ValueError: chord_steps ãŒç©º
    """
    if not chord_steps:
        msg = "chord_steps cannot be empty"
        raise ValueError(msg)

    # ã‚¹ãƒ†ãƒƒãƒ—1: å‘¨æ³¢æ•°å¤‰æ›
    fundamentals = [
        self._tuning_system.get_frequency(step) for step in chord_steps
    ]

    # ã‚¹ãƒ†ãƒƒãƒ—2: å€éŸ³åˆ—ç”Ÿæˆ
    harmonic_series_list = [
        self._timbre_model.generate_harmonics(
            fundamental=freq,
            num_harmonics=self._num_harmonics
        )
        for freq in fundamentals
    ]

    # ã‚¹ãƒ†ãƒƒãƒ—3: å…¨å€éŸ³ã‚’å¹³å¦åŒ–
    all_harmonics: list[Harmonic] = []
    for series in harmonic_series_list:
        all_harmonics.extend(series.harmonics)

    # ã‚¹ãƒ†ãƒƒãƒ—4: ãƒšã‚¢ãƒ¯ã‚¤ã‚ºãƒ©ãƒ•ãƒã‚¹è¨ˆç®—
    total_roughness = 0.0
    num_pairs = 0

    for i in range(len(all_harmonics)):
        for j in range(i + 1, len(all_harmonics)):
            roughness = calculate_roughness_pair(
                all_harmonics[i], all_harmonics[j]
            )
            total_roughness += roughness
            num_pairs += 1

    # çµæœã‚’è¿”ã™
    return ConsonanceResult(
        total_roughness=total_roughness,
        num_notes=len(chord_steps),
        num_harmonic_pairs=num_pairs,
        tuning_system=self._tuning_system,
    )
```

**å®Ÿè£…ã®è©³ç´°:**

1. **æ®µéšçš„å‡¦ç†**: å‘¨æ³¢æ•° â†’ å€éŸ³ â†’ ãƒšã‚¢ãƒ¯ã‚¤ã‚ºè¨ˆç®— ã¨æ˜ç¢ºã«åˆ†é›¢
2. **ãƒã‚¹ãƒˆãƒ«ãƒ¼ãƒ—**: `i < j` ã§é‡è¤‡ã‚’é¿ã‘ã‚‹
3. **ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼**: `num_pairs` ã§å®Ÿéš›ã«è¨ˆç®—ã—ãŸãƒšã‚¢æ•°ã‚’è¨˜éŒ²

**è¨ˆç®—é‡:**

- éŸ³æ•° $N$, å€éŸ³æ•° $M$ ã®ã¨ã
- ç·å€éŸ³æ•°: $N \times M$
- ãƒšã‚¢æ•°: $\binom{N \times M}{2} = \frac{(NM)(NM-1)}{2}$
- è¨ˆç®—é‡: $O(N^2 M^2)$

---

## 5. API Layerå®Ÿè£…

API Layerã¯ã€å¤–éƒ¨ï¼ˆUIå±¤ï¼‰ã‹ã‚‰ã®å…¥åŠ›ã‚’æ¤œè¨¼ã—ã€Serviceå±¤ã‚’å‘¼ã³å‡ºã™ã€‚

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/calculator.py`

### 5.1 ChordInputæ¤œè¨¼ãƒ¢ãƒ‡ãƒ«

```python
from pydantic import BaseModel, Field, field_validator

class ChordInput(BaseModel):
    """å’ŒéŸ³å…¥åŠ›ã®æ¤œè¨¼ãƒ¢ãƒ‡ãƒ«ã€‚"""

    edo: int = Field(gt=0, description="Equal divisions of the octave (N-EDO)")
    notes: list[int] = Field(
        min_length=1,
        description="List of note indices in the EDO system"
    )

    @field_validator("notes")
    @classmethod
    def validate_notes(cls, v: list[int], info: Any) -> list[int]:
        """éŸ³ç¬¦ãŒEDOç¯„å›²å†…ã§ã‚ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã€‚"""
        edo = info.data.get("edo")
        if edo and any(note < 0 or note >= edo for note in v):
            msg = f"All notes must be in range [0, {edo - 1}]"
            raise ValueError(msg)
        return v
```

**Pydanticã®åˆ©ç‚¹:**

1. **å®£è¨€çš„**: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆ¶ç´„ã‚’æ˜ç¤ºçš„ã«è¨˜è¿°
2. **è‡ªå‹•æ¤œè¨¼**: ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–æ™‚ã«è‡ªå‹•ã§ãƒã‚§ãƒƒã‚¯
3. **ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸**: è©³ç´°ãªæ¤œè¨¼ã‚¨ãƒ©ãƒ¼ã‚’è‡ªå‹•ç”Ÿæˆ

### 5.2 calculate_consonance APIé–¢æ•°

```python
def calculate_consonance(
    edo: int,
    notes: list[int],
    base_frequency: float = DEFAULT_BASE_FREQUENCY,
    num_harmonics: int = DEFAULT_NUM_HARMONICS,
) -> float:
    """å”å’Œåº¦ã‚’è¨ˆç®—ï¼ˆAPIé–¢æ•°ï¼‰ã€‚

    Args:
        edo: N-EDOå€¤
        notes: éŸ³ç¬¦ã‚¹ãƒ†ãƒƒãƒ—ã®ãƒªã‚¹ãƒˆ
        base_frequency: åŸºæº–å‘¨æ³¢æ•° (Hz)
        num_harmonics: å€éŸ³æ•°

    Returns:
        ç·ãƒ©ãƒ•ãƒã‚¹ï¼ˆfloatï¼‰

    Raises:
        ValidationError: å…¥åŠ›ãŒç„¡åŠ¹
    """
    # Pydanticæ¤œè¨¼
    ChordInput(edo=edo, notes=notes)

    # ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç”Ÿæˆ
    tuning_system = TuningSystem(edo=edo, base_frequency=base_frequency)
    timbre_model = SawtoothTimbre()
    calculator = ConsonanceCalculator(
        tuning_system=tuning_system,
        timbre_model=timbre_model,
        num_harmonics=num_harmonics,
    )

    # è¨ˆç®—å®Ÿè¡Œ
    result = calculator.calculate_consonance(chord_steps=notes)

    # ç·ãƒ©ãƒ•ãƒã‚¹ã®ã¿è¿”ã™ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªAPIï¼‰
    return result.total_roughness
```

**APIãƒ‡ã‚¶ã‚¤ãƒ³ã®åŸå‰‡:**

1. **ã‚·ãƒ³ãƒ—ãƒ«ãªå…¥å‡ºåŠ›**: float in, float out
2. **å†…éƒ¨ã®è©³ç´°ã‚’éš è”½**: `ConsonanceResult` ã®è©³ç´°ã¯å†…éƒ¨ã§å‡¦ç†
3. **æ¤œè¨¼ã‚’æœ€åˆã«**: Pydanticæ¤œè¨¼ â†’ ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯

---

## 6. Presenter Layerå®Ÿè£…

Presenter Layerã¯ã€Serviceå±¤ã‚„APIå±¤ã‹ã‚‰å—ã‘å–ã£ãŸç”Ÿãƒ‡ãƒ¼ã‚¿ã‚’UIè¡¨ç¤ºç”¨ã«æ•´å½¢ã—ã€ViewModelã¨ã—ã¦æä¾›ã™ã‚‹ã€‚ã“ã®å±¤ã«ã‚ˆã‚Šã€UIãƒ­ã‚¸ãƒƒã‚¯ï¼ˆè¡¨ç¤ºæº–å‚™ï¼‰ã¨æç”»ãƒ­ã‚¸ãƒƒã‚¯ãŒæ˜ç¢ºã«åˆ†é›¢ã•ã‚Œã€ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£ãŒå‘ä¸Šã™ã‚‹ã€‚

**ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª**: `src/visualization/`

### 6.1 è¨­è¨ˆæ€æƒ³ï¼šPresenter/ViewModel ãƒ‘ã‚¿ãƒ¼ãƒ³

#### 6.1.1 å•é¡Œæ„è­˜

å¾“æ¥ã®Streamlitã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã€è¡¨ç¤ºæº–å‚™ãƒ­ã‚¸ãƒƒã‚¯ã€æç”»ã‚³ãƒ¼ãƒ‰ãŒå˜ä¸€ã®ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ`app.py`ï¼‰ã«æ··åœ¨ã—ãŒã¡ã§ã‚ã‚‹ã€‚ã“ã®çµæœï¼š

- **ãƒ†ã‚¹ãƒˆãŒå›°é›£**: Streamlitä¾å­˜ã®ã‚³ãƒ¼ãƒ‰ã¯Pytestã§ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã§ããªã„
- **ä¿å®ˆæ€§ã®ä½ä¸‹**: è²¬å‹™ãŒä¸æ˜ç­ã§ã€å¤‰æ›´ã®å½±éŸ¿ç¯„å›²ãŒèª­ã¿å–ã‚Šã«ãã„
- **å†åˆ©ç”¨æ€§ã®æ¬ å¦‚**: åŒã˜è¡¨ç¤ºæº–å‚™ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¤‡æ•°ã®ãƒ“ãƒ¥ãƒ¼ã§å†åˆ©ç”¨ã§ããªã„

#### 6.1.2 è§£æ±ºç­–ï¼šè²¬å‹™ã®åˆ†é›¢

**Presenterå±¤ï¼ˆ`src/visualization`ï¼‰**:
- Serviceå±¤ã‹ã‚‰ç”Ÿãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹
- UIè¡¨ç¤ºã®ãŸã‚ã®è¨ˆç®—ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ»çµ±è¨ˆå‡¦ç†ã‚’è¡Œã†
- ã‚°ãƒ©ãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆPlotly Figureãªã©ï¼‰ã‚’ç”Ÿæˆ
- ã™ã¹ã¦ã‚’`ViewModel`ï¼ˆãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ï¼‰ã«ã¾ã¨ã‚ã¦è¿”ã™
- **Streamlitã«ä¾å­˜ã—ãªã„** â†’ Pytestã§ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆå¯èƒ½

**Viewå±¤ï¼ˆ`ui/`ï¼‰**:
- Presenterã‹ã‚‰`ViewModel`ã‚’å—ã‘å–ã‚‹
- `st.*`ã‚³ãƒãƒ³ãƒ‰ã§æç”»ã™ã‚‹ã®ã¿
- **Streamlitã«ä¾å­˜** â†’ `AppTest`ã§çµ±åˆãƒ†ã‚¹ãƒˆ

### 6.2 ViewModelãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/visualization/models.py`

```python
@dataclass(frozen=True)
class HarmonicPairData:
    """å€éŸ³ãƒšã‚¢ã®è©³ç´°ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚°ãƒ©ãƒ•æç”»ç”¨ï¼‰ã€‚"""
    freq1: float
    freq2: float
    amp1: float
    amp2: float
    normalized_freq_diff: float
    dissonance_value: float
    roughness_contribution: float
    is_self_interference: bool
    note_index1: int
    note_index2: int
    harmonic_number1: int
    harmonic_number2: int
```

**è¨­è¨ˆã®ãƒã‚¤ãƒ³ãƒˆ**:
- `frozen=True`: ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«
- UIè¡¨ç¤ºã«å¿…è¦ãªã™ã¹ã¦ã®æƒ…å ±ã‚’å«ã‚€
- Streamlitã«ä¾å­˜ã—ãªã„ç´”ç²‹ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ 

### 6.3 å…·ä½“ä¾‹ï¼šDissonanceCurvePresenter

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/visualization/dissonance_curve.py`

#### 6.3.1 Presenterã®è²¬å‹™

```python
def create_dissonance_curve(
    pair_data: list[HarmonicPairData],
    edo: int,
    chord_steps: list[int],
) -> go.Figure:
    """ä¸å”å’Œæ›²ç·šã‚°ãƒ©ãƒ•ã‚’ç”Ÿæˆã€‚

    Args:
        pair_data: å€éŸ³ãƒšã‚¢è©³ç´°ãƒ‡ãƒ¼ã‚¿
        edo: N-EDOå€¤
        chord_steps: å’ŒéŸ³ã‚¹ãƒ†ãƒƒãƒ—

    Returns:
        Plotly Figure ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    """
    # ãƒ‡ãƒ¼ã‚¿ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨é›†è¨ˆ
    df = _prepare_dataframe(pair_data)

    # ã‚°ãƒ©ãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ
    fig = go.Figure()

    # æ•£å¸ƒå›³ã®è¿½åŠ 
    fig.add_trace(go.Scatter(...))

    # ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š
    fig.update_layout(...)

    return fig
```

**é‡è¦ãªç‰¹å¾´**:
1. **Streamlitéä¾å­˜**: `import streamlit` ã¯ä¸€åˆ‡ãªã—
2. **ç´”ç²‹é–¢æ•°**: åŒã˜å…¥åŠ›ã‹ã‚‰å¸¸ã«åŒã˜å‡ºåŠ›
3. **ãƒ†ã‚¹ãƒˆå¯èƒ½**: Pytestã§`isinstance(fig, go.Figure)`ã‚’æ¤œè¨¼å¯èƒ½

#### 6.3.2 ãƒ‡ãƒ¼ã‚¿æº–å‚™é–¢æ•°

```python
def _prepare_dataframe(pair_data: list[HarmonicPairData]) -> pd.DataFrame:
    """ãƒšã‚¢ãƒ‡ãƒ¼ã‚¿ã‚’DataFrameã«å¤‰æ›ã—ã€é›†è¨ˆå‡¦ç†ã‚’è¡Œã†ã€‚"""
    df = pd.DataFrame([
        {
            'freq_diff': data.normalized_freq_diff,
            'dissonance': data.dissonance_value,
            'roughness': data.roughness_contribution,
            'is_self': data.is_self_interference,
        }
        for data in pair_data
    ])

    # é›†è¨ˆå‡¦ç†
    aggregated = df.groupby('freq_diff').agg({
        'dissonance': 'mean',
        'roughness': 'sum',
    }).reset_index()

    return aggregated
```

### 6.4 HistoryPresenter

**ãƒ•ã‚¡ã‚¤ãƒ«**: `src/visualization/history_presenter.py`

#### 6.4.1 ViewModelå®šç¾©

```python
@dataclass(frozen=True)
class ObservationItemViewModel:
    """å˜ä¸€ã®è¦³æ¸¬ã‚¢ã‚¤ãƒ†ãƒ ã®è¡¨ç¤ºç”¨ãƒ‡ãƒ¼ã‚¿ã€‚"""
    obs: Observation
    is_pinned: bool
    index: int  # ãƒ”ãƒ³ç•™ã‚ã¾ãŸã¯å±¥æ­´å†…ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

@dataclass(frozen=True)
class HistoryViewModel:
    """å±¥æ­´ãƒ“ãƒ¥ãƒ¼å…¨ä½“ã®è¡¨ç¤ºç”¨ãƒ‡ãƒ¼ã‚¿ã€‚"""
    all_items: list[ObservationItemViewModel]
```

#### 6.4.2 Presenterãƒ­ã‚¸ãƒƒã‚¯

```python
def prepare_history_view(
    pinned: list[Observation],
    history: list[Observation],
) -> HistoryViewModel:
    """å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºç”¨ViewModelã«å¤‰æ›ã€‚

    Args:
        pinned: ãƒ”ãƒ³ç•™ã‚ã•ã‚ŒãŸè¦³æ¸¬
        history: å±¥æ­´ï¼ˆæ–°ã—ã„é †ï¼‰

    Returns:
        HistoryViewModel
    """
    # ãƒ”ãƒ³ç•™ã‚ã‚¢ã‚¤ãƒ†ãƒ ã®æº–å‚™
    pinned_items = [
        ObservationItemViewModel(obs=obs, is_pinned=True, index=idx)
        for idx, obs in enumerate(pinned)
    ]

    # é‡è¤‡ã‚’é™¤å¤–ã—ãŸå±¥æ­´ã‚¢ã‚¤ãƒ†ãƒ ã®æº–å‚™
    pinned_set = set(pinned)
    unpinned_items = [
        ObservationItemViewModel(obs=obs, is_pinned=False, index=idx)
        for idx, obs in enumerate(reversed(history))
        if obs not in pinned_set
    ]

    return HistoryViewModel(all_items=pinned_items + unpinned_items)
```

### 6.5 Presenterå±¤ã®ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

Presenterå±¤ã¯**Pytestã§ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ**ã™ã‚‹ï¼š

```python
def test_create_dissonance_curve_returns_figure():
    """ã‚°ãƒ©ãƒ•ç”Ÿæˆé–¢æ•°ãŒPlotly Figureã‚’è¿”ã™ã“ã¨ã‚’æ¤œè¨¼ã€‚"""
    # Arrange
    pair_data = [
        HarmonicPairData(
            freq1=440.0, freq2=554.37,
            amp1=1.0, amp2=0.8,
            normalized_freq_diff=0.26,
            dissonance_value=0.42,
            roughness_contribution=0.336,
            is_self_interference=False,
            note_index1=0, note_index2=1,
            harmonic_number1=1, harmonic_number2=1,
        )
    ]

    # Act
    fig = create_dissonance_curve(pair_data, edo=12, chord_steps=[0, 7])

    # Assert
    assert isinstance(fig, go.Figure)
    assert len(fig.data) > 0
```

**ãƒ†ã‚¹ãƒˆã®ç„¦ç‚¹**:
- æ­£ã—ã„å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã‹
- ãƒ‡ãƒ¼ã‚¿ãŒé©åˆ‡ã«é›†è¨ˆã•ã‚Œã¦ã„ã‚‹ã‹
- ã‚°ãƒ©ãƒ•ã®åŸºæœ¬æ§‹é€ ãŒæ­£ã—ã„ã‹

---

## 7. UI Layerå®Ÿè£…

UI Layerã¯Streamlitã‚’ä½¿ç”¨ã—ã€ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªWebã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã™ã‚‹ã€‚Presenterå±¤ãŒæº–å‚™ã—ãŸ`ViewModel`ã‚’å—ã‘å–ã‚Šã€`st.*`ã‚³ãƒãƒ³ãƒ‰ã§æç”»ã™ã‚‹ã“ã¨ã«å°‚å¿µã™ã‚‹ã€‚

**ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª**: `ui/`

### 7.1 è¨­è¨ˆæ€æƒ³

1. **å³åº§ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯**: å…¥åŠ›å¤‰æ›´æ™‚ã«è‡ªå‹•å†è¨ˆç®—
2. **æ®µéšçš„æƒ…å ±é–‹ç¤º**: ãƒ¡ã‚¤ãƒ³ç”»é¢ã¯æœ€å°é™ã€è©³ç´°ã¯Expanderã§æŠ˜ã‚ŠãŸãŸã¿
3. **æ•™è‚²çš„è¦ç´ **: è¨ˆç®—ã®ä»•çµ„ã¿ã‚’å¹³æ˜“ã«èª¬æ˜
4. **Presenter/Viewåˆ†é›¢**: ViewModelã‚’å—ã‘å–ã‚Šã€æç”»ã®ã¿ã«å°‚å¿µ

### 7.2 è²¬å‹™ã®æ˜ç¢ºåŒ–

**Viewå±¤ãŒã™ã¹ãã“ã¨**:
- Presenterã‹ã‚‰`ViewModel`ã‚’å—ã‘å–ã‚‹
- `st.*`ã‚³ãƒãƒ³ãƒ‰ã§ç”»é¢ã«æç”»ã™ã‚‹
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ãªã©ï¼‰ã‚’æ¤œå‡ºã—ã€Presenterã‚’å‘¼ã³å‡ºã™

**Viewå±¤ãŒã™ã¹ãã§ãªã„ã“ã¨**:
- ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆè¨ˆç®—ã€ãƒ‡ãƒ¼ã‚¿åŠ å·¥ãªã©ï¼‰
- è¤‡é›‘ãªæ¡ä»¶åˆ†å²ã‚„ãƒ«ãƒ¼ãƒ—
- ã‚°ãƒ©ãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ

### 7.3 ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

#### 7.3.1 ã‚µã‚¤ãƒ‰ãƒãƒ¼è¨­å®šï¼ˆå¾“æ¥é€šã‚Šï¼‰

```python
with st.sidebar:
    st.header("Settings")

    edo = st.number_input(
        "EDO (Equal Divisions of Octave)",
        min_value=1,
        max_value=100,
        value=12,
        help="Number of equal divisions per octave."
    )

    base_frequency = st.number_input(
        "Base Frequency (Hz)",
        min_value=20.0,
        max_value=2000.0,
        value=440.0,
        step=1.0,
    )

    num_harmonics = st.slider(
        "Number of Harmonics",
        min_value=1,
        max_value=20,
        value=10,
    )
```

#### 7.3.2 å’ŒéŸ³å…¥åŠ›ã¨ãƒ—ãƒªã‚»ãƒƒãƒˆ

```python
chord_input = st.text_input(
    "Enter note steps (comma-separated)",
    value="0, 4, 7",  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: é•·3å’ŒéŸ³
)

# ãƒ—ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
if st.button("Major Triad"):
    chord_input = "0, 4, 7"
if st.button("Minor Triad"):
    chord_input = "0, 3, 7"
```

#### 7.3.3 çµæœè¡¨ç¤ºï¼ˆPresenter/Viewåˆ†é›¢å¾Œï¼‰

```python
# ãƒ©ãƒ•ãƒã‚¹è¨ˆç®—
roughness = calculate_consonance(
    edo=edo,
    notes=notes,
    base_frequency=base_frequency,
    num_harmonics=num_harmonics,
)

# ãƒ¡ãƒˆãƒªãƒƒã‚¯è¡¨ç¤º
st.metric(
    label="Acoustic Roughness",
    value=f"{roughness:.4f}",
    help="Lower values = higher consonance"
)

# è§£é‡ˆ
if roughness < 0.05:
    interpretation = "Very Consonant ğŸ¶"
elif roughness < 0.15:
    interpretation = "Consonant âœ…"
elif roughness < 0.30:
    interpretation = "Moderately Consonant ğŸµ"
elif roughness < 0.50:
    interpretation = "Moderately Dissonant âš ï¸"
else:
    interpretation = "Dissonant âŒ"
```

### 7.4 ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```python
try:
    notes = [int(n.strip()) for n in chord_input.split(",")]
except ValueError:
    st.error("Invalid input format. Please enter comma-separated integers.")

try:
    roughness = calculate_consonance(...)
except ValidationError as e:
    st.error(f"Invalid input: {e}")
except Exception as e:
    st.error(f"Error calculating consonance: {e}")
```

---

## 8. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒå¯Ÿ

### 8.1 è¨ˆç®—æ™‚é–“ã®å®Ÿæ¸¬

**ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ç’°å¢ƒ:**
- CPU: Intel Core i7 / Apple M1ç›¸å½“
- Python 3.13
- NumPy 1.26+

**çµæœ:**

| å’ŒéŸ³ | å€éŸ³æ•° | ç·å€éŸ³æ•° | ãƒšã‚¢æ•° | è¨ˆç®—æ™‚é–“ |
|-----|-------|---------|--------|---------|
| å˜éŸ³ [0] | 10 | 10 | 45 | 0.2 ms |
| 2éŸ³ [0,7] | 10 | 20 | 190 | 0.3 ms |
| 3å’ŒéŸ³ [0,4,7] | 10 | 30 | 435 | 0.5 ms |
| 6éŸ³ [0,2,4,5,7,9] | 10 | 60 | 1770 | 1.5 ms |
| 3å’ŒéŸ³ [0,4,7] | 20 | 60 | 1770 | 1.8 ms |

**çµè«–:** ã™ã¹ã¦ãƒŸãƒªç§’ã‚ªãƒ¼ãƒ€ãƒ¼ã§å®Œäº†ã€‚ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ä½¿ç”¨ã«ååˆ†é«˜é€Ÿã€‚

### 8.2 ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã¨æœ€é©åŒ–

#### 8.2.1 ç¾çŠ¶ã®ãƒœãƒˆãƒ«ãƒãƒƒã‚¯

1. **ãƒšã‚¢ãƒ¯ã‚¤ã‚ºãƒ«ãƒ¼ãƒ—**: $O(N^2 M^2)$ ã®äºŒé‡ãƒ«ãƒ¼ãƒ—
2. **æŒ‡æ•°é–¢æ•°è¨ˆç®—**: `np.exp()` ãŒå„ãƒšã‚¢ã§2å›å‘¼ã°ã‚Œã‚‹

#### 8.2.2 æœ€é©åŒ–ã®ä½™åœ°ï¼ˆæœªå®Ÿè£…ï¼‰

**NumPyãƒ™ã‚¯ãƒˆãƒ«åŒ–:**

```python
# ç¾åœ¨ã®å®Ÿè£…ï¼ˆã‚¹ã‚«ãƒ©ãƒ¼ãƒ«ãƒ¼ãƒ—ï¼‰
for i in range(len(harmonics)):
    for j in range(i + 1, len(harmonics)):
        roughness += calculate_roughness_pair(harmonics[i], harmonics[j])

# æœ€é©åŒ–æ¡ˆï¼ˆãƒ™ã‚¯ãƒˆãƒ«åŒ–ï¼‰
freqs = np.array([h.frequency for h in harmonics])
amps = np.array([h.amplitude for h in harmonics])

# å…¨ãƒšã‚¢ã®å‘¨æ³¢æ•°å·®è¡Œåˆ—
freq_diff_matrix = np.abs(freqs[:, None] - freqs[None, :])

# æŒ¯å¹…ç©è¡Œåˆ—
amp_matrix = amps[:, None] * amps[None, :]

# ... ãƒ™ã‚¯ãƒˆãƒ«åŒ–ã•ã‚ŒãŸãƒ©ãƒ•ãƒã‚¹è¨ˆç®— ...
```

**æœŸå¾…ã•ã‚Œã‚‹é«˜é€ŸåŒ–:** 2-5å€ï¼ˆãŸã ã—å¯èª­æ€§ã¨ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ï¼‰

### 8.3 ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£

**ç¾å®Ÿçš„ãªä½¿ç”¨ç¯„å›²:**

- å’ŒéŸ³: 1-10éŸ³ï¼ˆé€šå¸¸ã¯3-4éŸ³ï¼‰
- å€éŸ³: 5-20ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10ï¼‰
- EDO: 5-100ï¼ˆé€šå¸¸12, 19, 31, 53ï¼‰

ã“ã®ç¯„å›²ã§ã¯ã€ç¾åœ¨ã®å®Ÿè£…ã§ååˆ†ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã€‚

---

**å‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ:** [1003. æ•°å­¦çš„åŸºç›¤](./1003.mathematical-foundation.md)

---

*ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€Xenharmonic Voyager MVPã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨å®Ÿè£…è©³ç´°ã‚’è¨˜è¿°ã—ã¦ã„ã¾ã™ã€‚æ•°å­¦çš„åŸºç›¤ã«ã¤ã„ã¦ã¯é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚*
