# Xenharmonic Voyager: UIテスト戦略

## 1. 概要と基本方針

本ドキュメントは、Xenharmonic VoyagerアプリケーションにおけるUI層のテスト戦略を定義します。主な目的は、「テストピラミッド」のアプローチを採用することにより、堅牢で保守性が高く、テストのしやすいUI層を構築することです。この戦略では、複数のテスト手法を、それぞれ異なる抽象レベルに適応させて組み合わせます。

**実装ステータス**: ✅ **完了** (2025-10-17)

## 2. テストピラミッド

個々の関数から完全なユーザー体験まで、包括的なカバレッジを確保するために、2階層のテスト戦略を採用します。

### レベル1: ユニットテスト (Pytest)
- **ツール**: `Pytest`
- **対象**: Streamlitフレームワークに依存しない純粋なロジック関数。ビジネスロジック、データ変換、計算、表示準備ロジックなどが含まれます。
- **配置場所**: `src/` 内のすべてのモジュール。
- **論拠**: 最も高速で信頼性の高いテストです。個々のコンポーネントの正しさを分離された状態で保証し、我々のテストピラミッドの幅広い土台を形成します。

### レベル2: 統合テスト (Streamlit `AppTest`)
- **ツール**: `streamlit.testing.v1.AppTest`
- **対象**: UIコンポーネントとアプリケーションの状態（`st.session_state`）との間のインタラクション。「ボタンをクリックしたら、セッションの状態が正しく更新され、UIがその変更を反映するか？」といったシナリオのテストに最適です。
- **配置場所**: `tests/ui/`
- **論拠**: `AppTest`は、完全なE2Eテストよりもはるかに高速でありながら、実際のブラウザなしで複数のUIコンポーネントの連携を検証できる中間的な立ち位置を提供します。

## 3. テスト容易性のためのリファクタリング: Presenter/View パターン

UIコードのテストにおける主要な課題は、アプリケーションロジックと描画コードの混在です。これを解決するため、UIコンポーネントを「Presenter（ロジック担当）」と「View（描画担当）」に明確に分離します。

- **問題点**: 単一の関数が、表示用の値の計算と、`st.metric`などによる描画の両方に責任を持っている。これにより、Pytestでのユニットテストが困難になっている。

- **解決策**: 以下の通り、責務を明確に分離します。
    1.  **Presenter (`src/visualization`層)**: UIに表示するための、あらゆる準備ロジックを担当します。コアサービスから生データを受け取り、UI固有の計算（フィルタリング、統計など）を行い、グラフオブジェクトを生成し、それらすべてを`ViewModel`（表示用データクラス）にまとめて返します。**この層はPytestでテストします。**
    2.  **View (`ui`層)**: Presenterが準備した`ViewModel`を受け取り、その中身を`st.*`コマンドを使って画面に描画することだけに責任を持ちます。**この層は`AppTest`でテストします。**

## 4. ディレクトリ構成と規約

プロジェクトのアーキテクチャは、以下のシンプルなルールによって統治されます。

- **責務分離の基本ルール**:
    - **`src` ディレクトリ**: `streamlit`を**インポートしない**、すべてのモジュールを配置します。これには、コアなドメインロジック、サービス、そしてUI表示のための準備ロジック（Presenter）が含まれます。
    - **`ui` ディレクトリ**: `streamlit`を**インポートする**、すべてのモジュールを配置します。これは純粋なView（描画）層です。

- **`src/visualization`の役割**:
    - このディレクトリは、UIのための**Presenter層**として機能します。特定のUIビューに表示するためのデータを準備するロジック（統計計算、グラフ生成など）をここに集約します。

- **テストディレクトリ**:
    - `ui`層のテストを格納するため、`tests/ui/`ディレクトリを新たに作成します。
