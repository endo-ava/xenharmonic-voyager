# Xenharmonic Voyager: テスト戦略

**最終更新**: 2025-10-18

## 1. 概要と基本方針

本ドキュメントは、Xenharmonic Voyagerアプリケーション全体のテスト戦略を定義します。主な目的は、「テストピラミッド」のアプローチを採用することにより、堅牢で保守性が高く、テストのしやすいシステムを構築することです。この戦略では、複数のテスト手法を、それぞれ異なる抽象レベル（ユニット、統合、UI）に適応させて組み合わせます。

**実装ステータス**: ✅ **完了** (2025-10-17)

## 2. テストピラミッド

個々の関数から完全なユーザー体験まで、包括的なカバレッジを確保するために、2階層のテスト戦略を採用します。

### レベル1: ユニットテスト (Pytest)
- **ツール**: `Pytest`
- **対象**: Streamlitフレームワークに依存しない純粋なロジック関数。ビジネスロジック、データ変換、計算、表示準備ロジックなどが含まれます。
- **配置場所**: `src/` 内のすべてのモジュール。
- **論拠**: 最も高速で信頼性の高いテストです。個々のコンポーネントの正しさを分離された状態で保証し、我々のテストピラミッドの幅広い土台を形成します。

### レベル2: 統合テスト (Streamlit `AppTest`)
- **ツール**: `streamlit.testing.v1.AppTest`
- **対象**: UIコンポーネントとアプリケーションの状態（`st.session_state`）との間のインタラクション。「ボタンをクリックしたら、セッションの状態が正しく更新され、UIがその変更を反映するか？」といったシナリオのテストに最適です。
- **配置場所**: `tests/ui/`
- **論拠**: `AppTest`は、完全なE2Eテストよりもはるかに高速でありながら、実際のブラウザなしで複数のUIコンポーネントの連携を検証できる中間的な立ち位置を提供します。

## 3. テスト容易性のためのリファクタリング: Presenter/View パターン

UIコードのテストにおける主要な課題は、アプリケーションロジックと描画コードの混在です。これを解決するため、UIコンポーネントを「Presenter（ロジック担当）」と「View（描画担当）」に明確に分離します。

- **問題点**: 単一の関数が、表示用の値の計算と、`st.metric`などによる描画の両方に責任を持っている。これにより、Pytestでのユニットテストが困難になっている。

- **解決策**: 以下の通り、責務を明確に分離します。
    1.  **Presenter (`src/visualization`層)**: UIに表示するための、あらゆる準備ロジックを担当します。コアサービスから生データを受け取り、UI固有の計算（フィルタリング、統計など）を行い、グラフオブジェクトを生成し、それらすべてを`ViewModel`（表示用データクラス）にまとめて返します。**この層はPytestでテストします。**
    2.  **View (`ui`層)**: Presenterが準備した`ViewModel`を受け取り、その中身を`st.*`コマンドを使って画面に描画することだけに責任を持ちます。**この層は`AppTest`でテストします。**

## 4. ディレクトリ構成と規約

プロジェクトのアーキテクチャは、以下のシンプルなルールによって統治されます。

- **責務分離の基本ルール**:
    - **`src` ディレクトリ**: `streamlit`を**インポートしない**、すべてのモジュールを配置します。これには、コアなドメインロジック、サービス、そしてUI表示のための準備ロジック（Presenter）が含まれます。
    - **`ui` ディレクトリ**: `streamlit`を**インポートする**、すべてのモジュールを配置します。これは純粋なView（描画）層です。

- **`src/visualization`の役割**:
    - このディレクトリは、UIのための**Presenter層**として機能します。特定のUIビューに表示するためのデータを準備するロジック（統計計算、グラフ生成など）をここに集約します。

- **テストディレクトリ**:
    - `ui`層のテストを格納するため、`tests/ui/`ディレクトリを新たに作成します。

---

## 5. 全体テストカバレッジ

### 5.1 テスト統計

**全体統計:**
- 総テスト数: **126テスト以上**（Presenter層テスト追加）
- コードカバレッジ: **100%**（コア層）、**96%**（Presenter層）
- テスト実行時間: **< 1秒**

### 5.2 層別テスト構成

| 層 | テストファイル | テスト数 | カバレッジ | テスト手法 |
|----|--------------|---------|-----------|----------|
| Domain - Tuning | `test_tuning.py` | 29 | 100% | Pytest |
| Domain - Harmonics | `test_harmonics.py` | 31 | 100% | Pytest |
| Acoustics | `test_roughness.py` | 28 | 100% | Pytest |
| Service | `test_consonance_service.py` | 18 | 100% | Pytest |
| API | `test_calculator.py` | 20 | 100% | Pytest |
| **Presenter** | `test_*_presenter.py` | 30+ | 96% | **Pytest** |
| **UI (View)** | `test_*_view.py` | 10+ | N/A | **AppTest** |

**Presenter層テストの重要性**:
- Presenter層は**Streamlitに依存しない**ため、Pytestで高速にテスト可能
- グラフ生成ロジック、データ集計ロジックの正しさを保証
- UI層のテスト負荷を軽減

---

## 6. テスト設計原則

### 6.1 AAA (Arrange-Act-Assert) パターン

すべてのテストは、AAA（Arrange-Act-Assert）パターンに従います。

```python
def test_12edo_octave_doubles_frequency():
    # Arrange: テストデータの準備
    tuning = TuningSystem(edo=12, base_frequency=440.0)

    # Act: テスト対象の実行
    freq = tuning.get_frequency(12)

    # Assert: 結果の検証
    assert freq == pytest.approx(880.0)
```

**利点**:
1. **可読性**: テストの意図が明確
2. **保守性**: 構造が統一されているため、修正が容易
3. **デバッグ性**: 失敗箇所の特定が容易
